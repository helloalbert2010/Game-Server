# 游戏计时机制说明

## 计时原理

本平台的游戏计时**完全在客户端（浏览器）进行**，不受网络延迟或服务器响应时间影响。

### F1 反应测试游戏

```javascript
// 开始计时（绿灯亮起时）
startTime = performance.now();

// 用户点击时计算反应时间
const reactionTime = (performance.now() - startTime) / 1000;
```

**关键点**：
- 使用 `performance.now()` API，精度达到微秒级别
- 计时完全在浏览器本地进行
- 与服务器无任何交互

### 舒尔特方格游戏

```javascript
// 开始计时
startTime = Date.now();

// 每10毫秒更新显示
setInterval(() => {
  const elapsed = (Date.now() - startTime) / 1000;
  timer.textContent = elapsed.toFixed(2);
}, 10);
```

**关键点**：
- 使用 `Date.now()` API，精度达到毫秒级别
- 计时器每10毫秒更新一次显示
- 所有计算在浏览器本地完成

## 成绩上传流程

```
┌─────────────────┐
│  本地游戏计时    │ ← 纯客户端，不受网络影响
└────────┬────────┘
         │
         ▼
┌─────────────────┐
│  显示成绩给玩家  │ ← 立即显示，无延迟
└────────┬────────┘
         │
         ▼
┌─────────────────┐
│  上传到服务器    │ ← 异步操作，不阻塞
└─────────────────┘
```

### 代码实现

```javascript
async function finishGame(time) {
  // 1. 立即显示本地计算的成绩
  resultTime.textContent = (time * 1000).toFixed(0) + 'ms';
  resultDisplay.style.display = 'block';

  // 2. 异步上传（不阻塞）
  try {
    await submitScore('f1_reaction', time);
    statusMessage.textContent = '成绩已保存！';
  } catch (error) {
    // 即使上传失败，本地成绩仍然准确
    statusMessage.textContent = '成绩上传失败（本地成绩已记录）';
  }
}
```

## 性能对比

### 传统服务器计时（❌ 不推荐）
```
用户点击 → 发送到服务器 → 服务器计算 → 返回结果
    ↑_______________________________________↑
              网络延迟计入总时间
```

### 本地客户端计时（✅ 当前实现）
```
用户点击 → 本地立即计算 → 显示结果
                      ↓
                 异步上传到服务器
```

## 技术细节

### performance.now() API
- **精度**: 微秒级（0.001ms）
- **参考点**: 页面加载时间
- **不受系统时间调整影响**
- **专门用于性能测量**

### Date.now() API
- **精度**: 毫秒级（1ms）
- **参考点**: Unix 时间戳
- **适合短时间测量**
- **跨浏览器兼容性好**

## 防作弊措施

虽然计时在客户端进行，但我们采取了以下措施：

1. **服务器验证**: 成绩上传时服务器检查数据合理性
2. **异常检测**: 识别不可能的反应时间（如 < 100ms）
3. **历史分析**: 追踪用户的成绩趋势
4. **管理员审核**: 管理员可查看和删除可疑成绩

## 总结

✅ **反应时间 100% 本地计算**
✅ **不受网络延迟影响**
✅ **成绩立即显示，上传不阻塞**
✅ **上传失败不影响本地成绩记录**

你可以放心游玩，计时是准确和公平的！
